<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<section>
    <h2>二叉树的性质</h2>
    <dl>
        <dd>任意一节点的值均大于其左孩子的值，小于其有孩子的值</dd>
    </dl>
</section>
<section>
    <h2>问题</h2>
    <dl>
        <dd>怎么实现二叉树</dd>
        <dd>定义二叉树可以存贮数据</dd>
        <dd>利用二叉树的特性进行排序</dd>
    </dl>
</section>
<script>
    // 基本的二叉树样子
    var tree = {
        value: 1,
        left: {
            value: 2,
            left: {
                value: 4
            }
        },
        right: {
            value: 3,
            left: {
                value: 5,
                left: {
                    value: 7
                },
                right: {
                    value: 8
                }
            },
            right: {
                value: 6
            }
        }
    };

    /**
     * 二叉树实现
     * @constructor
     */
    function BinaryTree() {
        this.rootNode = null;
        var _Node = function (parentNode, leftNode, rightNode) {
            this.parentNode = parentNode;
            this.leftNode = leftNode;
            this.rightNode = rightNode;
        };
        this.fnInsert = function (value) {
            var node = new _Node(value, null, null);
            if (this.rootNode == null) {
                this.rootNode = node;
            } else {
                var currentNode = this.rootNode;
                while (currentNode) {
                    // 根据根节点判断 插入到左边还是右边 再判断找到当前节点 最后插入
                    if (value < currentNode.parentNode) {//插入到左边
                        if (currentNode.leftNode) {
                            currentNode = currentNode.leftNode;
                        } else {
                            currentNode.leftNode = node;
                            break;
                        }
                    } else {//插入到右边
                        if (currentNode.rightNode) {
                            currentNode = currentNode.rightNode;
                        } else {
                            currentNode.rightNode = node;
                            break;
                        }
                    }
                }
            }
        }.bind(this);
    }
    BinaryTree.prototype = {
        fnInOrder: function (treeNode) {//中序遍历 左根右
            var arr = [],
                    _fnSort = function (treeNode) {
                        if (treeNode) {
                            _fnSort(treeNode.leftNode);
                            arr.push(treeNode.parentNode);
                            _fnSort(treeNode.rightNode);
                        }
                        return arr;
                    };
            return treeNode ? _fnSort(treeNode) : '';
        },
        fnPreOrder: function (treeNode) {//先序遍历 根左右
            var arr = [],
                    _fnSort = function (treeNode) {
                        if (treeNode) {
                            arr.push(treeNode.parentNode);
                            _fnSort(treeNode.leftNode);
                            _fnSort(treeNode.rightNode);
                        }
                        return arr;
                    };
            return treeNode ? _fnSort(treeNode) : '';
        },
        fnPostOrder: function (treeNode) {//后序遍历 左右根
            var arr = [],
                    _fnSort = function (treeNode) {
                        if (treeNode) {
                            _fnSort(treeNode.leftNode);
                            _fnSort(treeNode.rightNode);
                            arr.push(treeNode.parentNode);
                        }
                        return arr;
                    };
            return treeNode ? _fnSort(treeNode) : '';
        }
    };

    // test 二叉树测试
    var binaryTree = new BinaryTree();
    binaryTree.fnInsert(23);
    binaryTree.fnInsert(45);
    binaryTree.fnInsert(16);
    binaryTree.fnInsert(37);
    binaryTree.fnInsert(3);
    binaryTree.fnInsert(99);
    binaryTree.fnInsert(22);
    console.log(binaryTree);
    console.log(binaryTree.fnInOrder(binaryTree.rootNode));
    console.log(binaryTree.fnPreOrder(binaryTree.rootNode));
    console.log(binaryTree.fnPostOrder(binaryTree.rootNode));
</script>
</body>
</html>
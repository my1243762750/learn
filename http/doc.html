<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        section, article {
            font-size: 24px;
        }
    </style>
</head>
<body>
<section>
    <h4>http常用的请求类型</h4>
    <ul>
        <li>get 查询</li>
        <li>post 保存、添加</li>
        <li>put 修改</li>
        <li>delete 删除</li>
    </ul>
</section>
<section>
    <h4>跨域有两种方式</h4>
    <ul>
        <li>简单请求 跨域</li>
        <li>非简单请求 跨域</li>
    </ul>
</section>
<section>
    <h4>
        http提交数据的方式，用Content-Type来描述(有：text/plain、application/json、application/x-www-form-urlencoded、multipart/form-data)</h4>
    <ul>
        <li>text/plain 提交文本数据，客户端默认的数据格式</li>
        <li>application/json 提交json数据，而且需要序列化,JSON.stringify({})</li>
        <li>application/json (以nodejs为服务的话，需要bodyParser插件解析)</li>
        <li>application/x-www-form-urlencoded 提交表单，参数是{user:1234,pwd:1234},最终提交服务器的是user=1234&pwd=1234</li>
        <li>multipart/form-data 提交视频或文件</li>
        <li>multipart/form-data (以nodejs为服务的话，需要connect-multiparty插件解析)</li>
        <li>
            <a href="http://blog.csdn.net/jiangcs520/article/details/70141901">更多详情</a>
        </li>
    </ul>
</section>
<article>
    <h2>请求头参数</h2>
    <ul>
        <li>accept:application/json,text/plain,*/*(客户端希望服务器返回的数据类型(MIME))</li>
        <li>
            content-Type(发送给服务器的数据类型(MIME),有：application/x-www-form-urlencoded、multipart/form-data、text/plain,例:text/plain;charset=UTF-8)
        </li>
        <li>accept-Encoding:gzip,deflate,sdch(客户端能够解码的方式)</li>
        <li>accept-Language:zh-CN;q=0.8;(客户端可接受的语言)</li>
        <li>Origin:http://localhost:63342(如果是跨域请求，浏览器会自动添加这个属性)</li>
        <li>Access-Control-Request-Method: PUT(如果是跨域非简单请求，浏览器会自动添加这个属性)</li>
        <li>Access-Control-Request-Headers: content-type(如果是跨域非简单请求，浏览器会自动添加这个属性)</li>
        <li><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html">更多详情</a></li>

        <li>cookie</li>
        <li>connection:keep-alive</li>
        <li>content-Length(请求类容的长度)</li>
        <li>host和Referer(分别表示url中的主机、端口号和一个完整url)</li>
        <li>User-Agent(浏览器信息)</li>
        <li>Pragma:http1.0就有的特性</li>
        <li>Cache-control:http1.1新加的特性(这个属性是来设置要不要去读缓存)</li>
        <li>If-Modified-Since:记录文件最新的修改时间</li>
        <li>If-none-match:请求数据在服务器的唯一标识</li>
    </ul>
</article>
<article>
    <h2>响应头参数</h2>
    <ul>
        <li>
            content-Type(返回给客户端的数据类型(MIME),有：application/x-www-form-urlencoded、multipart/form-data、text/plain,例:text/plain;charset=UTF-8)
        </li>
        <li>content-Encoding(指定解码方式，从客户端指定的方式选择)</li>
        <li>Access-Control-Allow-Origin:*服务器允许跨域请求，*代表允许所有域请求)</li>
        <li>Access-Control-Allow-Methods: 'PUT, GET, POST, DELETE, OPTIONS'(服务器允许的请求方式)</li>
        <li>Access-Control-Expose-Headers:'FooBar'(服务器允许客户端，可以获取额外的响应头信息)</li>

        <li>content-Length:6456(这个需要请求头connection:keep-alive)</li>
        <li>Expires:缓存的过期时间</li>
        <li>Date(日期)</li>
        <li>etag:请求数据在服务器的唯一标识</li>
        <li>Last-Modified:返回文件最新的修改时间</li>
    </ul>
</article>
<section>
    <h4>回答请求头和响应头的有哪些，从以下几个方面回答</h4>
    <ul>
        <li>缓存涉及的几个属性</li>
        <li>请求方法和参数涉及的几个属性</li>
    </ul>
</section>
<section>
    <h4>get 和 post 的content-type</h4>
    <ul>
        <li>get  的请求头没有 content-type</li>
        <li>post 的请求头有  content-type: application/json                  提交json数据，而且需要序列化,JSON.stringify({})</li>
        <li>post 的请求头有  content-type: application/x-www-form-urlencoded 提交表单，参数是{user:1234,pwd:1234},最终提交服务器的是user=1234&pwd=1234</li>
        <li>post 的请求头有  content-type: multipart/form-data               提交视频或文件，如果是表单提交，form的enctype属性必须指定为multipart/form-data</li>
        <li>post 的请求头有  content-type: text/xml</li>
    </ul>
    <ul>
        <li>get 请求头</li>
        <li>Accept: application/json, text/plain, */*</li>
        <li>Accept-Encoding: gzip, deflate, br</li>
        <li>Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6</li>
        <li>get 响应头</li>
        <li>content-type: application/json;charset=UTF-8</li>
        <li>Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6</li>
    </ul>
</section>
<article>
    <h2>缓存涉及的几个属性</h2>
    <ul>
        <li>http1.0:Expires(缓存过期时间，绝对时间)、Pragma(是否缓存) (这两个属性在请求头)</li>
        <li>http1.1:Cache-Control(是否缓存，和过期时间，相对时间) (这个属性在响应头或请求头)</li>
        <li>http1.1:If-None-Match和If-Modified-Since(当缓存时间过期时，服务器返回新的数据，还是从缓存里取) (这两个属性在请求头)</li>
        <li>http1.1:ETag、Last-Modified(当缓存时间过期时，服务器返回新的数据，还是从缓存里取) (这两个属性在响应头)</li>
        <li>缓存分为：强缓存和协商缓存</li>
        <li>强缓存属性：Expires和Cache-Control</li>
        <li>协商缓存属性：If-Modified-Since，Last-Modified，ETag，If-None-Match</li>
        <li>缓存先判断强缓存在判断协商缓存</li>
        <li>强缓存中Cache-Control > Expires</li>
        <li><a href="https://www.cnblogs.com/softidea/p/5986339.html">相关链接</a></li>
    </ul>
</article>
<article>
    <h2>http返回类型</h2>
    <ul>
        <li>200: 请求被正常处理</li>
        <li>302：临时重定向</li>
        <li>304：资源没有被改过</li>
        <li>400：请求参数格式有问题</li>
        <li>403：禁止访问</li>
        <li>404: 客户端访问的地址写错了</li>
        <li>405: Method Not Allowed</li>
        <li>500：服务器内部错误</li>
        <li>503：服务器停止了或重启</li>
        <li>504：服务器超时</li>
    </ul>
</article>
<article>
    <h2>cookie和session的由来，以及websocket</h2>
    <ul>
        <li>无连接：请求时建连接、请求完释放连接。（用户量大，所有用户都保持连接，服务器压力大）</li>
        <li>keep-alive：保持一段时间的连接。（页面复杂，每次重新连接，效率显得较低）</li>
        <li>无状态：每次请求都是独立的。（无法记住上一次请求的状态，那岂不是每次请求，服务器都要验证是否登录了）</li>
        <li>cookie和session。（登录之后，服务器验证成功后生成一个编码，返回给浏览器，并用cookie保存，同时服务器用session保存这个编码）</li>
        <li>websocket</li>
        <li>页面和接口 都会有登录的验证</li>
        <li>xss</li>
        <li>cors</li>
        <li>set-cookie：cookieKey=cookieValue;domian=.paic.com.cn;path=/;HttpOnly</li>
    </ul>
</article>
<article>
    <h4>长连接、短链接、长轮询、短轮询</h4>
    <ul>
        <li>建立连接-》数据传输-》关闭连接</li>
        <li>建立连接-》数据传输-》保持连接-》数据传输-》关闭连接</li>
        <li>http1.0采用短链接</li>
        <li>http1.1采用长链接</li>
        <li>长连接相对于短链接而言，少了频繁的三次握手操作</li>
        <li>短轮询：一定循环周期内，客户端发起请求-》服务端一定即时响应请求-》客户端发起请求-》服务端一定即时响应请求</li>
        <li>长轮询：一定循环周期内，客户端发起请求-》（数据没变化，可以不响应，但保持连接挂起）服务端不一定即时响应请求-》客户端发起请求-》（数据没变化，可以不响应，但保持连接挂起）服务端不一定即时响应请求</li>
        <li>Request Header(请求头参数):Connection: keep-alive</li>
        <li>Request Header(请求头参数):Keep-Alive: timeout=5,max=100(过期时间5s，超过100次请求断开)</li>
    </ul>
</article>
<article>
    <h2 class="my-hidden">http请求问题和相关链接</h2>
    <dl>
        <dt>http请求问题和相关链接</dt>
        <dd>浏览器每次发起请求，都会同时请求一次favicon.ico 浏览器默认会请求这个地址来获取图标；这个图标是地址栏中网站的小图标（或用户放入收藏夹时会显示）</dd>
        <dd>http请求referer和origin区别</dd>
        <dd><a href="http://www.iteye.com/topic/1123380">http都要请求favicon.ico</a></dd>
        <dd><a href="http://www.iteye.com/topic/1123380">referer和origin</a></dd>
    </dl>
</article>
<article>
    <h2 class="my-hidden">计算机网络有七层和四层</h2>
    <dl>
        <dt>TCP/IP四层和OSI七层</dt>
        <dd>物理链路层/物理层、数据链路层</dd>
        <dd>网络层/网络层</dd>
        <dd>传输层/传输层（TCP、UDP）</dd>
        <dd>应用层/会话层、表示层、应用层（HTTP、RTSP、FTP）</dd>
    </dl>
</article>
<article>
    <h2 class="my-hidden">http和https</h2>
    <dl>
        <dt>http和https</dt>
        <dd>http和https使用的是完全不同的连接方式,用的端口也不一样,前者是80,后者是443</dd>
        <dd>http的连接很简单,是无状态的</dd>
        <dd>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议要比http协议安全</dd>
    </dl>
</article>
<article>
    <h2 class="my-hidden">可以申请免费的SSL证书机构</h2>
    <dl>
        <dt>可以申请免费的SSL证书机构</dt>
        <dd><a href="http://www.enet.com.cn/article/2016/1025/A20161025021560.html">证书机构</a></dd>
        <dd><a href="https://www.aliyun.com/">阿里云</a> 也可以申请免费证书，因为它聚集了有资质的第三方机构</dd>
    </dl>
</article>
<article>
    <h2 class="my-hidden">https服务器的搭建</h2>
    <dl>
        <dt>https服务器的搭建</dt>
        <dd>1申请域名，SSL证书需要域名</dd>
        <dd>2申请SSL证书,创建https服务器需要SSL证书</dd>
        <dd>3创建https服务器</dd>
        <dd>就这简单3步，但具体操作还是个问题；好在阿里云有从申请域名到https服务器使用SSL证书的详细流程</dd>
    </dl>
</article>
<article>
    <pre>
        response header
        Access-Control-Allow-Credentials: true
        Access-Control-Allow-Headers: x-auth-token
        Access-Control-Allow-Methods: GET
        Access-Control-Allow-Origin: http://emall.abcdexyz1-icrcment.com.cn:9988

        request header
        Access-Control-Request-Headers: x-auth-token
        Access-Control-Request-Method: POST
    </pre>
</article>
<article>
    <ul>
        <li>referer 和 origin 和 host</li>
        <li>connection: keep-alive</li>
        <li>Proxy-Connection:keep-alive</li>
        <li>Accept:*/*</li>
    </ul>
</article>
<article>
    <ul>
        <li>Origin: https://sitweb.dashuini.com</li>
        <li>Referer: https://sitweb.dashuini.com/platform/index.html</li>
        <li>Origin: http://platform.abcdexyz1-icrcment.com.cn:9528</li>
        <li>Referer: http://platform.abcdexyz1-icrcment.com.cn:9528/</li>
    </ul>
</article>
<article>
    <ul>
        <li>https://www.cnblogs.com/heluan/p/8620312.html</li>
    </ul>
</article>
</body>
</html>
